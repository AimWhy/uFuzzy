<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>μFuzzy</title>

		<style>
			*,
			*::before,
			*::after {
				box-sizing: border-box;
			}

			body {
				margin: 0;
			}

			pre {
				margin: 0;
				display: inline-block;
				vertical-align: top;
				overflow: auto;
				margin-top: 20px;
				/* overflow: auto; */
				/* box-shadow: 3px 3px 3px rgb(0 0 0 / 20%); */
				/* height: 600px; */
			}

			pre b {
				color: red;
			}

			i {
				font-style: normal;
				color: silver;
			}

			input[type=text].uf {
				width: 50px;
			}

			label {
				margin-left: 20px;
			}

			label > * {
				vertical-align: middle;
			}

			#search {
				font-size: 16pt;
			}

			#opts,
			input,
			select {
				font-family: monospace;
			}

			#search,
			#opts {
				vertical-align: middle;
			}

			#opts {
				background: #e0e0e0;
				padding: 8px 12px;
			}
		</style>
	</head>
	<body>
		<div>
			<div id="opts">
				<input id="search" type="text" placeholder="Search...">

				<label>
					Lists
					<select id="lists" multiple>
						<option value="urls_and_titles_600">urls_and_titles_600</option>
						<option value="hearthstone_750">hearthstone_750</option>
						<option value="metric_name_9000">metric_name_9000</option>
						<option value="metric_type_9000">metric_type_9000</option>
						<option value="metric_help_9000">metric_help_9000</option>
						<option value="ue4_files_13000">ue4_files_13000</option>
						<option value="mtg_16000">mtg_16000</option>
						<option value="steam_games_47000">steam_games_47000</option>
						<option value="wordlist_58000">wordlist_58000</option>
					</select>
				</label>

				<label style="font-size: 12pt;"><b>uFuzzy opts:</b></label>

				<label>
					intraLimit
					<input class="uf" id="intraLimit" type="text" value="0" placeholder="Inf">
				</label>
				<label>
					interLimit
					<input class="uf" id="interLimit" type="text" placeholder="Inf">
				</label>
				<label>
					<input class="uf" id="strictPre" type="checkbox" placeholder="Inf">
					strictPre
				</label>
				<label>
					<input class="uf" id="strictSuf" type="checkbox">
					strictSuf
				</label>
				<label>
					<input class="uf" id="outOfOrder" type="checkbox">
					outOfOrder
				</label>
				<label>
					<input class="uf" id="withRanges" type="checkbox" checked>
					withRanges
				</label>
				<label>
					rankThresh
					<input class="uf" id="rankThresh" type="text" value="1000" placeholder="Inf">
				</label>
				<label>
					sortPreset
					<select id="sortPreset">
						<option value="search">Search</option>
						<option value="typeahead">Typeahead</option>
					</select>
				</label>
			</div>
		</div>

		<script>
			let urlParams = new URLSearchParams(location.search);

			for (let [k, v] of urlParams) {
				let inp = document.getElementById(k);

				if (inp) {
					if (inp.matches('input[type=checkbox]'))
						inp.checked = v != '0' && v != 'false';
					else if (k == 'lists') {
						let lists = new Set(v.split(','));

						[...inp.querySelectorAll('option')].forEach(option => {
							option.selected = lists.has(option.value);
						});
					}
					else
						inp.value = v == 'inf' ? '' : v;

					if (k == 'search')
						document.title = 'μFuzzy - ' + v;
				}
			}

			if (urlParams.get('lists') == null) {
				[...document.querySelectorAll('#lists option')].forEach(option => {
					option.selected = true;
				});
			}

			function fmtResult(lib, found, toStr, haystack, elapsed) {
				let allCount = haystack.length.toLocaleString("en-US");
				let foundCount = found.length.toLocaleString("en-US");

				found = found.slice(0, 300).map(r => toStr(r).replace(/[\n\r]+/g, ' '));

				return [
					`${lib.name} <a href="${lib.repo}" target="_blank">repo</a>` + (lib.demo ? ` <a href="${lib.demo}" target="_blank">demo</a>` : ''),
					'='.repeat(50),
					`${foundCount} results (out of ${allCount}), ${elapsed.toFixed(1)}ms`,
					'',
					found.join('\n'),
				].join('\n');
			}

			function highlightParts(str, ranges) {
				let dst = str.substring(0, ranges[0]);

				for (let i = 0; i < ranges.length; i+=2) {
					let fr = ranges[i];
					let to = ranges[i+1];

					dst += '<b>' + str.substring(fr, to) + '</b>';

					if (i < ranges.length - 3)
						dst += str.substring(ranges[i+1], ranges[i+2]);
				}

				dst += str.substring(ranges[ranges.length - 1]);

				return dst;
			}

			// copy & tweak from core
			const cmp = new Intl.Collator('en').compare;
			const typeAheadSort = (stats, haystack, needle) => {
				let { idx, term, pre0, pre1, suf0, suf1, span, start, intra, inter } = stats;

				return {
					stats,
					order: idx.map((v, i) => i).sort((ia, ib) => (
							intra[ia] - intra[ib] // least char intra-fuzz (most contiguous)
						|| start[ia] - start[ib] // earliest start of match
						|| haystack[idx[ia]].length - haystack[idx[ib]].length // shortest match first
						|| ( // most prefix/suffix bounds, boosted by full term matches
							(term[ib] + pre0[ib] + 0.5 * pre1[ib] + suf0[ib] + 0.5 * suf1[ib]) -
							(term[ia] + pre0[ia] + 0.5 * pre1[ia] + suf0[ia] + 0.5 * suf1[ia])
						)
					//	|| span[ia] - span[ib] // highest density of match (least span)
						|| inter[ia] - inter[ib] // highest density of match (least term inter-fuzz)
						|| cmp(haystack[idx[ia]], haystack[idx[ib]]) // alphabetic
					)),
				};
			};

			function timeIt(fn) {
				let start = performance.now();
				fn();
				return performance.now() - start;
			}

			// https://stackoverflow.com/questions/9960908/permutations-in-javascript/37580979#37580979
			function permute(arr) {
				let length = arr.length,
					result = [arr.slice()],
					c = new Array(length).fill(0),
					i = 1, k, p;

				while (i < length) {
					if (c[i] < i) {
						k = i % 2 && c[i];
						p = arr[i];
						arr[i] = arr[k];
						arr[k] = p;
						++c[i];
						i = 1;
						result.push(arr.slice());
					} else {
						c[i] = 0;
						++i;
					}
				}

				return result;
			}

			const latinize = (() => {
				let accents = {
					A: 'ÁÀÃÂÄ',
					a: 'áàãâä',
					E: 'ÉÈÊË',
					e: 'éèêë',
					I: 'ÍÌÎÏ',
					i: 'íìîï',
					O: 'ÓÒÔÕÖ',
					o: 'óòôõö',
					U: 'ÚÙÛÜ',
					u: 'úùûü',
					C: 'Ç',
					c: 'ç',
					N: 'Ñ',
					n: 'ñ'
				};

				let accentsMap = new Map();
				let accentsTpl = '';

				for (let r in accents) {
					accents[r].split('').forEach(a => {
						accentsTpl += a;
						accentsMap.set(a, r);
					});
				}

				let accentsRe = new RegExp(`[${accentsTpl}]`, 'g');

				return strings => {
					let out = Array(strings.length);
					for (let i = 0; i < strings.length; i++)
						out[i] = strings[i].replace(accentsRe, m => accentsMap.get(m));
					return out;
				};
			})();

			let tmpOnlyLib = null;
			let tmpVar;

			let libs = [
				{
					name: 'uFuzzy',
					script: '../dist/uFuzzy.iife.js',
					fulltext: false,
					repo: 'https://github.com/leeoniya/uFuzzy',
					demo: 'https://leeoniya.github.io/uFuzzy/demos/compare.html',
					opts: {
						intraLimit: (tmpVar = urlParams.get('intraLimit')) == null ? 0 : tmpVar == 'inf' ? Infinity : +tmpVar,
					//	intraChars: '.',

						interLimit: (tmpVar = urlParams.get('interLimit')) == null ? Infinity : tmpVar == 'inf' ? Infinity : +tmpVar,
					//	interChars: '.',

						strictPre:  (tmpVar = urlParams.get('strictPre'))  != null && (tmpVar == '' || tmpVar == 'true' || tmpVar == '1'),
						strictSuf:  (tmpVar = urlParams.get('strictSuf'))  != null && (tmpVar == '' || tmpVar == 'true' || tmpVar == '1'),

						withRanges: (tmpVar = urlParams.get('withRanges')) == null ||  tmpVar == '' || tmpVar == 'true' || tmpVar == '1',

						sort: urlParams.get('sortPreset') == 'typeahead' ? typeAheadSort : null,
					},
					setup: (haystack, opts) => {
						if (opts.sort == null)
							delete opts.sort;

						let u = new uFuzzy(opts);

						let rankThresh = 1e3;

						document.getElementById('rankThresh').addEventListener('input', e => {
							rankThresh = +e.target.value;
							ufSearch(e);
						});

						const bump = e => {
							let v = e.target.value;

							if (e.code == 'ArrowUp') {
								if (v == '')
									e.target.value = '0';
								else
									e.target.value = +v + 1;
							}
							else if (e.code == 'ArrowDown') {
								if (v == '') return;

								if (v == '0')
									e.target.value = '';
								else
									e.target.value = +v - 1;
							}

							e.target.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));
						};

						const ufSearch = e => {
							tmpOnlyLib = 'uFuzzy';
							document.getElementById("search").dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));
							tmpOnlyLib = null;
						};

						document.getElementById('intraLimit').addEventListener('keyup', bump);
						document.getElementById('intraLimit').addEventListener('input', e => {
							let v = e.target.value;
							opts.intraLimit = v == '' ? Infinity : +e.target.value;
							u = new uFuzzy(opts);
							ufSearch(e);
						});

						document.getElementById('interLimit').addEventListener('keyup', bump);
						document.getElementById('interLimit').addEventListener('input', e => {
							let v = e.target.value;
							opts.interLimit = v == '' ? Infinity : +e.target.value;
							u = new uFuzzy(opts);
							ufSearch(e);
						});

						document.getElementById('strictPre').addEventListener('input', e => {
							opts.strictPre = e.target.checked
							u = new uFuzzy(opts);
							ufSearch(e);
						});

						document.getElementById('strictSuf').addEventListener('input', e => {
							opts.strictSuf = e.target.checked
							u = new uFuzzy(opts);
							ufSearch(e);
						});

						let oooPermute = false;

						document.getElementById('outOfOrder').addEventListener('input', e => {
							oooPermute = e.target.checked;
							ufSearch(e);
						});

						document.getElementById('withRanges').addEventListener('input', e => {
							opts.withRanges = e.target.checked;
							u = new uFuzzy(opts);
							ufSearch(e);
						});

						document.getElementById('sortPreset').addEventListener('change', e => {
							if (e.target.value == 'typeahead')
								opts.sort = typeAheadSort;
							else
								delete opts.sort;

							u = new uFuzzy(opts);
							ufSearch(e);
						});

						let toStr;

						return {
							search: needle => {
								if (oooPermute) {
									let needles = permute(needle.split(/[^A-Za-z0-9]+/g)).map(terms => terms.join(' '));

									let allFound = [];
									let allStats = {};

									needles.forEach((needle, pi) => {
										let idxs = u.filter(haystack, needle);
										let found = idxs;
										toStr = idx => haystack[idx];

										if (idxs.length <= rankThresh) {
											let { stats, order } = u.score(idxs, haystack, needle);
											found = order;

											// offset idxs for concat'ing stats
											if (pi > 0) {
												for (let i = 0; i < found.length; i++)
													found[i] += allFound.length;
											}

											for (let k in stats)
												allStats[k] = (allStats[k] ?? []).concat(stats[k]);

											if (opts.withRanges)
												toStr = oi => highlightParts(haystack[allStats.idx[oi]], allStats.ranges[oi]);
											else
												toStr = oi => haystack[allStats.idx[oi]];
										}

										allFound = allFound.concat(found); // re-rank?
									});

									return allFound;
								}
								else {
									let idxs = u.filter(haystack, needle);
									let found = idxs;
									toStr = idx => haystack[idx];

									if (idxs.length <= rankThresh) {
										let { stats, order } = u.score(idxs, haystack, needle);
										found = order;

										if (opts.withRanges)
											toStr = oi => highlightParts(haystack[stats.idx[oi]], stats.ranges[oi]);
										else
											toStr = oi => haystack[stats.idx[oi]];
									}

									return found;
								}
							},
							toStr: m => toStr(m),
						};
					},
					search: null,
					toStr: null,
				},
				{
					name: 'Fuzzyset',
					script: './lib/fuzzyset.js',
					fulltext: true,
					repo: 'https://github.com/Glench/fuzzyset.js',
					demo: 'http://glench.github.io/fuzzyset.js/',
					opts: {},
					setup: (haystack, opts) => {
						let fuzzySet = FuzzySet();

						for (let i = 0; i < haystack.length; i++)
							fuzzySet.add(haystack[i]);

						return {
							search: needle => {
								return fuzzySet.get(needle);
							},
							toStr: m => m[1],
						};
					},
					search: null,
					toStr: null,
				},
				{
					name: 'QuickScore',
					script: './lib/quick-score.min.js',
					fulltext: false,
					repo: 'https://github.com/fwextensions/quick-score',
					demo: 'https://fwextensions.github.io/quick-score-demo/',
					opts: {},
					setup: (haystack, opts) => {
						const qs = new quickScore.QuickScore(haystack);

						return {
							search: needle => {
								return qs.search(needle);
							},
							toStr: m => {
								return `<i>${+m.score.toFixed(3)}</i> ` + highlightParts(m.item, m.matches.flat());
							},
						};
					},
					search: null,
					toStr: null,
				},
				{
					name: 'fuzzysort',
					script: './lib/fuzzysort.min.js',
					fulltext: true,
					repo: 'https://github.com/farzher/fuzzysort',
					demo: 'https://rawgit.com/farzher/fuzzysort/master/test.html',
					opts: {
					//	limit: 100, // don't return more results than you need!
					//	threshold: -10000, // don't return bad results
					},
					setup: (haystack, opts) => {
						haystack = haystack.map(s => fuzzysort.prepare(s));

						return {
							search: needle => {
								return fuzzysort.go(needle, haystack, opts);
							},
							toStr: m => {
								return `<i>${+m.score.toFixed(4)}</i> ` + fuzzysort.highlight(m);
							},
						};
					},
					search: null,
					toStr: null,
				},
				{
					name: 'FuzzySearch',
					script: './lib/FuzzySearch.js',
					fulltext: false,
					repo: 'https://github.com/wouter2203/fuzzy-search',
					opts: {
						caseSensitive: false,
						sort: true,
					},
					setup: (haystack, opts) => {
						haystack = haystack.map(s => ({s}));
						let fuzzySearch = new FuzzySearch(haystack, ['s'], opts);

						return {
							search: needle => {
								return fuzzySearch.search(needle);
							},
							toStr: m => m.s,
						};
					},
					search: null,
					toStr: null,
				},
				{
					name: 'FuzzySearch2',
					fulltext: false,
					script: './lib/FuzzySearch2.min.js',
					repo: 'https://github.com/jeancroy/FuzzySearch',
					demo: 'https://rawgit.com/jeancroy/FuzzySearch/master/demo/autocomplete.html',
					opts: {},
					setup: (haystack, opts) => {
						let searcher = new FuzzySearch2({source: haystack});

						return {
							search: needle => {
								return searcher.search(needle);
							},
							toStr: m => m,
						};
					},
					search: null,
					toStr: null,
				},
				{
					name: 'fuzzysearch',
					script: './lib/fuzzysearch.js',
					fulltext: false,
					repo: 'https://github.com/bevacqua/fuzzysearch',
					demo: 'https://bevacqua.github.io/horsey/',
					opts: {},
					setup: (haystack, opts) => {
						return {
							search: needle => {
								let matches = [];

								for (let i = 0; i < haystack.length; i++) {
									if (fuzzysearch(needle, haystack[i]))
										matches.push(haystack[i]);
								}

								return matches;
							},
							toStr: m => m,
						};
					},
					search: null,
					toStr: null,
				},
				{
					name: 'match-sorter',
					script: './lib/match-sorter.umd.min.js',
					fulltext: false,
					repo: 'https://github.com/kentcdodds/match-sorter',
					demo: 'https://codesandbox.io/s/wyk856yo48',
					opts: {keepDiacritics: true},
					setup: (haystack, opts) => {
						return {
							search: needle => {
								return matchSorter.matchSorter(haystack, needle, opts);
							},
							toStr: m => m,
						};
					},
					search: null,
					toStr: null,
				},
				{
					name: 'Fuse',
					script: './lib/fuse.min.js',
					fulltext: true,
					repo: 'https://github.com/krisk/Fuse',
					demo: 'https://fusejs.io/demo.html',
					opts: {
						includeScore: true,
						includeMatches: true,
					},
					setup: (haystack, opts) => {
					//	const index = Fuse.createIndex([], haystack);
						const index = null;
						const fuse = new Fuse(haystack, opts, index);

						return {
							search: needle => {
							//	debugger;
								return fuse.search(needle);
							},
							toStr: m => `<i>${+m.score.toFixed(4)}</i> ` + highlightParts(m.item, m.matches[0].indices.flat()),
						};
					},
					search: null,
					toStr: null,
				},
				{
					name: 'LiquidMetal',
					script: './lib/liquidmetal.js',
					fulltext: false,
					repo: ' https://github.com/rmm5t/liquidmetal',
					opts: {},
					setup: (haystack, opts) => {
						return {
							search: needle => {
								let scores = Array(haystack.length);

								for (let i = 0; i < haystack.length; i++) {
									scores.push({
										i,
										score: LiquidMetal.score(haystack[i],  needle),
									});
								}

								return scores.filter(m => m.score > 0).sort((a, b) => a.score - b.score);
							},
							toStr: m => haystack[m.i],
						};
					},
					search: null,
					toStr: null,
				},
				{
					name: 'fuzzyMatch',
					script: './lib/fuzzyMatch.js',
					fulltext: false,
					repo: 'https://github.com/grafana/grafana/blob/main/packages/grafana-ui/src/utils/fuzzy.ts',
					opts: {},
					setup: (haystack, opts) => {
						return {
							search: needle => {
								let found = [];

								needle = needle.toLowerCase();

								for (let i = 0; i < haystack.length; i++) {
									let m = fuzzyMatch(haystack[i].toLowerCase(), needle);
									if (m.found) {
										m.idx = i;
										found.push(m);
									}
								}

								found.sort((a,b) => a.distance - b.distance) || cmp(haystack[a.idx], haystack[b.idx]);

								return found;
							},
							toStr: m => haystack[m.idx],
						};
					},
					search: null,
					toStr: null,
				},
				{
					name: 'MiniSearch',
					script: './lib/minisearch.min.js',
					fulltext: true,
					repo: 'https://github.com/lucaong/minisearch',
					demo: 'https://lucaong.github.io/minisearch/examples/',
					opts: {},
					setup: (haystack, opts) => {
						let miniSearch = new MiniSearch({
							fields: ['s'],
						});

						miniSearch.addAll(haystack.map((s, i) => ({s, id: i})));

						return {
							search: needle => {
								return miniSearch.search(needle);
							},
							toStr: m => haystack[m.id],
						};
					},
					search: null,
					toStr: null,
				},
			/*
				{
					name: 'fzy',
					script: './lib/fzy.js',
					fulltext: false,
					repo: 'https://jhawthorn.github.io/fzy-demo/',
					demo: 'https://github.com/jhawthorn/fzy.js',
					opts: {},
					setup: (haystack, opts) => {
						return {
							search: needle => {
							//	list = list.filter((s) => fzy.hasMatch(s));

								// Sort by fzy's scoring, descending (higher scores are better matches)
								let out = haystack.map(s => -fzy.score(needle, s));
							},
							toStr: m => haystack[m.id],
						};
					},
					search: null,
					toStr: null,
				},
			*/
			//  TODO:
			//	https://github.com/nol13/fuzzball.js
			//	https://github.com/nextapps-de/flexsearch
			//	https://github.com/LyraSearch/lyra
			];
		</script>

		<script>
		//	'TrackMania12-y2 Uni_ted 17Webisode 1123: Coppers';
		//	abc col tow
		//	res to da
		//	promremstorfal;

			function setup(lib, haystack) {
				let {search, toStr} = lib.setup(haystack, lib.opts);
				lib.search = search;
				lib.toStr = toStr;
			}

			const allListNames = [
				'urls_and_titles_600',
				'hearthstone_750',
				'metric_name_9000',
				'metric_type_9000',
				'metric_help_9000',
				'ue4_files_13000',
				'mtg_16000',
				'steam_games_47000',
				'wordlist_58000',
			];

			fetch('./testdata.json').then(r => r.json()).then(data => {
			//	let haystack = data.steam_games;
			//	let haystack = data.wordlist_58k;
			//	let haystack = data.test;
			//	let haystack = data.metric_name;

				let listNames = urlParams.get('lists');

				if (listNames == null)
					listNames = allListNames;
				else
					listNames = listNames.split(',');

				let haystack = listNames.flatMap(k => data[k]);

				let listsEl = document.getElementById('lists');

				listsEl.addEventListener('change', e => {
					listNames = [...listsEl.querySelectorAll('option')].filter(option => option.selected).map(option => option.value);
					haystack = listNames.flatMap(k => data[k]);
					libNames.forEach(name => {
						let lib = libs.find(lib => lib.name == name);
						setup(lib, haystack);
						document.getElementById('search').dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));
					});
				});

			//	console.time('diacritics');
			//	haystack = latinize(haystack);
			//	console.timeEnd('diacritics');

				let libNames = urlParams.get('libs');

				if (libNames)
					libNames = libNames.split(',');
				else
					libNames = libs.map(lib => lib.name);

				let proms = [];

				libNames.forEach(name => {
					let lib = libs.find(lib => lib.name == name);

					if (lib) {
						proms.push(new Promise((resolve, reject) => {
							let sc = document.createElement('script');
							sc.src = lib.script;
							sc.onload = e => { resolve(lib); };
							document.body.appendChild(sc);
						}));
					}
				});

				Promise.all(proms).then(libs => {
					let search = document.getElementById('search').value;

					libs.forEach(l => {
						let res = document.createElement('pre');
						document.body.appendChild(res);
						res.style.width = Math.floor(100 / Math.min(libs.length, 5)) + '%';

						setup(l, haystack);

						let run = needle => {
							let elapsed = 0;
							let matches = [];

							if (needle != '') {
								elapsed = timeIt(() => {
									matches = l.search(needle) ?? [];
								});
							}

							res.innerHTML = fmtResult(l, matches, l.toStr, haystack, elapsed);
						};

						document.getElementById("search").addEventListener('input', e => {
							let needle = e.target.value

							if (tmpOnlyLib == null || tmpOnlyLib == l.name)
								run(needle);
						});

						run(search);
					});
				});
			});
		</script>
	</body>
</html>